PRO spectrum, modeldir,err_out, pwv_out, restore=restore

;Master script to generate the all total synthetic spectra from a single volume emission profile from the
;succesfull model run and all the possible temperature profiles generated by temp_prof.pro - probably saved 
;in some file to stop me having to generate them every time


;Inputs: 
;   modeldir: (string) - path leading to the location of the modelled event


;STEP 1 - READING THE MODEL TO RETRIEVE VOLUME EMISSION PROFILES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Need to pull out a number of N2 volume emission profiles a chosen time step apart over a chosen altitude range
; volume_em.pro does most of the hard work for this!

;Reading the model data

common emissions, em, br, alt, times, names_ems

if not(keyword_set(alt)) then begin
    read_em, 'emissions.dat', /silent
endif

alts = alt
n2 = reform(em[*,3,*]) 
;help, n2

; n2 volume emission array created, X dimension is time step, Y dimension is altitude. 'alt' variable is 
; the total alititude range, same dimensions as n2(#,*)

; now need to trim the arrays to vary between 80 and 200km to match the temperature profiles for easier
; spectra generature later

s = where(alts le 200)
hrange = alts[s]  ; n_elements = 101 - this is now the hrange which we will 'integrate' over to generate the
    	    	  ;spectra - need to interpolate the T profiles so i can pull out a value at each of these
		  ; values

;STEP 2 - GENERATING THE TEMPERATURE PROFILES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Need to either generate, or restore a save file which contains, the range of potential temperature
;profiles to be used to generate synthetic spectra

;Generate to begin with - could change to restore later but as it stands it doesn't take that long and
;I dislike cluttering directories with .sav files.

; going to play with the temperature ranges a bit
; [alititudes], [ranges], [initial temperatures]
;temp_prof, [80,100,125,150,200], [160,160,600,800,800],[220 ,200 ,500 ,700 ,800], prof, initial

temp_prof, [80,100,125,150,200], [100,100,600,600,800],[220 ,200 ,600 ,700 ,900], prof, initial


;cubic spline interpolation
; new array for interpolated profile storage

temp = dblarr(n_elements(prof[*,0]), n_elements(hrange))

for i=0, n_elements(prof[*,0]) -1 do begin
    T = prof[i,*]    ;temperatures - not always monotonically increasing
    A = initial[0,*] ;altitudes - always monotonically increasing
    T2 = SPL_INIT(A,T)
    A2 = hrange    
    Z = SPL_INTERP(A, T, T2, A2)
    temp[i,*] = Z   
endfor

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; STEP 3 - GENERATING/RESTORING EACH SYNTHETIC SPECTRA FOR ALL POSSIBLE TEMPERATURES

Trange = findgen(1270) + 50   ;integer steps of temp from 50 to 1319 - covering entire range of temp prof.
Trange = DOUBLE(Trange)


print, 'Restoring N2 spectra from file...'
restore, '~/Documents/N2spectra_wobs_zero.sav'
print, '...Done!'

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;retrieving Hities setup data for convolve procedure

tt_mjs, 2017, 01, 27, 20, 50, 00, 00, mjs
get_w, mjs, 2, wl_p   ;gets wavelength to pixel grid for panel 2 of hities at the given mjs

;width = 0.7581909   ;halfwidth
width = 0.8
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;GENERATING TOTAL SPECTRA FOR A SINGLE TIME STEP - EG A SINGLE VOLUME EMISSION RATE

;this will have to be a master loop through the model results at some point - not yet!
volem = reform(n2[33,100:-1])

tt_mjs, 2017, 01, 27, 10, 50, 40, 00, mjs1
tt_mjs, 2017, 01, 27, 10, 52, 40, 00, mjs2
    
;read_HiTIESsav, mjs1, mjs2, time, dseq, icount

restore, '$WKDIR/readtim.sav'
;restore, '$WKDIR/readtim_30s.sav'

;read_tim, '27/01/2017 20:40:40', 0.02, mjs0, time, dseq, /nophot, tadd=120. 


spectra, 2, mjs1, time, dseq, spectrum, str, tcount, scount  ;retrieve spectrum from instrument

wl_p=wl_p[40:312]
spectrum = spectrum[40:312]

;wl_p = shift(wl_p, -2)

err_out=[]
pwv_out=[]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

read_H2O_transmission_spectrum, file='~/Documents/H2Otrans_vs_wlair.dat'
common H2Otransspec, H2O_wl, PWVarr, H2O_transmission, H2O_file

;PWVrange=findgen(21)
PWVrange=findgen(5)*5.
;PWVrange=findgen(11)*2.
;PWVrange=findgen(2)*20.
;PWVrange=findgen(3)*10.

help, h2o_transmission
newh2o = dblarr(n_elements(PWVrange),n_elements(h2o_transmission[0,*]))

if n_elements(h2o_transmission[*,0]) eq 21 then begin 
    for k=0, n_elements(PWVrange)-1 do begin
    	newh2o[k,*] = double(h2o_transmission[(PWVrange[k]),*]) 
    endfor
endif

;h2o_transmission = new

help, h2o_transmission
help, newh2o

loadct,39
;window,0, xsize=800, ysize=1000
layout, 4, pos, cpos

g = (0.5*(shift(hrange,1) - shift(hrange, -1)))/hrange
dharr = hrange * mean(g[1:-2])

print, 'Number of T profiles: ', n_elements(temp[*,0])

for idt=0, n_elements(temp[*,0]) -1, 1 do begin 
    ;idt = round(randomu(seed) * n_elements(temp[*,0]))
    ;print, 'idt: ', idt
   
    t_prof = reform(temp[idt,*])	    ;save the temperature profile
    sys_1 = SYSTIME(/seconds)
    
    indspec=dblarr(n_elements(N_i[0,*])) ;arays for storing spectra
    tfinal=dblarr(n_elements(N_i[0,*]))

    ;looping up the altitude range
    for h=0, n_elements(hrange)-1, 1 do begin	
    	vol = volem[h]      	    ;save the current vol. emission rate at alt.
	dh = dharr[h]	    	    ;save current altitude step
	t_step = round(t_prof[h])   ;save the temp at alt. as nearest round integer	
	t_index = t_step - 50	    ;locate the index in the N_i array which corresponds to this temp
	
	if t_index ge n_elements(N_i[*,0]) then t_index = n_elements(N_i[*,0])-1  ;stops spline interpolation putting T out of range
	if t_index le 50 then t_index = 0
	
	indspec = reform(N_i[t_index,*])  * (vol)  * dh  ;retrieve spectra from restored file and apply vol. emission
	
	tfinal = tfinal + indspec  ;add each spectra to the total for this temp. profile
    endfor
    
    sys_2 = SYSTIME(/seconds)
    ;print, 'Height integration: ', sys_2 - sys_1
    
    ;Note: its called convovled and not convolved for 'historical reasons'
    convovled = dblarr(n_elements(PWVrange), n_elements(wl_p))  ;empty array for storing convolved linespectra
    
    ;filling the convovled array with convovled spectrum for all PWV values
    for idc=0, n_elements(PWVrange)-1 do begin
    	;tfinal[-1] = mean(tfinal,/nan)	    	    	    	    	;remove a nan
    	
	;tfinal_abs = tfinal * reverse(H2O_transmission[idc,*])      	;apply h2o absorption for each PWV value    
    	
	absarr = reform(newh2o[idc,*])
	tfinal_abs = tfinal * reverse(absarr)


	
	convolve_sp_david, wln2, tfinal_abs, width, wl_p, s_out   	;convovle onto instrument grid
    	s_out = s_out/max(s_out)    	    	    	    	    	;normalise
    	convovled[idc, *] = s_out   	    	    	    	    	;save spectra into convolved array
    endfor

    ;sys_3 = SYSTIME(/seconds)
    ;print, 'Convolution: ', sys_3 - sys_2
    
    plot, t_prof, hrange, POSITION=pos[*,0], xrange=[min(Trange), 1350.0], yrange=[75, 205]
    oplot, prof[idt, *], [80,100,125,150,200], PSYM=4
    plot, volem, hrange, POSITION=pos[*,1], /noerase
    
    ;Fit_o_david routines
    common N2synth, N2_temps, N2_spectra, N2_wl, N2_file, N2PWV ;common block from read_synthetic_n2.pro

    N2_spectra = transpose(convovled)	    	    	    	;defining variables in common block for fitting
    N2_file = 'ext_profile'   
    N2_wl = wl_p 	    	    	    	    	;wl_p is descending,convovled is ascending-so fixed it
    N2_temps = PWVrange *100.
    N2PWV = 8.	    
   	    	    	    	;fitting process
    fit_o_matic_evolv, N2_wl, spectrum, status, error, params, brfit, wl2, $ 
    	    	       linefile='~/input_fit_lines_Tnpanel.dat', N2file=N2_file, $
		       /quiet, PWV=N2PWV
    
    err_out=[err_out, error]	    	    	    	    	;saving fit outputs for analysis
    pwv_out=[pwv_out, params[-1]]

    plot, N2_wl, N2_spectra[*,0], POSITION=pos[*,2],/noerase
    plot, N2_wl, spectrum, POSITION=pos[*,3], /noerase
    oplot, N2_wl, brfit, color=250 
    
    sys_4 = SYSTIME(/seconds)
    ;print, 'Fitting: ', sys_4 - sys_3
    ;print, 'Total (s): ', sys_4 - sys_1
    
    if idt eq 0 then begin
    	tot= (sys_4-sys_1) * n_elements(temp[*,0])
	print, 'Estimated time to completion: ', round(tot)/(60.*60), ' hours.'
    endif

    print, params[-1], params[-4], error
    
    stop
    
endfor

END
